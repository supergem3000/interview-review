# 操作系统

## 内存管理

连续分配的方式会形成许多碎片，虽然可以通过紧凑的方式将许多碎片拼接成可用的大块空间，但需要很大的开销。如果能够将一个进程分散的装入到许多不相邻的分区中，那么可以充分利用内存空间，也不需要采用紧凑的方法去拼接碎片。基于这种离散分配的思想，根据分配地址空间的基本单位不同的，可以将离散分配分为：分页、分段和段页式。

### 分页存储管理

将用户程序的地址空间分为若干个固定大小区域（即页）。同时，也需要将内存空间分为若干个物理块或页框，块和页的大小相同，这样就可以将用户程序的任何页装入任一物理块中，实现离散分配。

页面大小的选择应当适中，通常为1KB ~ 8KB；页面过小，虽然会减少内存碎片，但会导致页表过大，占用大量内存，降低页面换进换出的效率；页面过大，虽然使页表变小，但是又会产生**内部碎片**。

![页面地址结构](https://zuyuxia.github.io//img/%E9%A1%B5%E9%9D%A2%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png)

### 分段存储管理

作业的地址空间被划分成若干段，每个段定义了一组逻辑信息。系统为每个分段分配一个连续的分区，进程中的各个分段可以离散的装入内存的不同分区中。分段存储管理可能产生**外部碎片**。

![分段地址结构](https://zuyuxia.github.io//img/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png)

### 段页式存储管理

页式存储管理方式适合高效率的利用存储空间。段式存储管理方式是从程序的角度来管理内存，便于程序的共享和保护。段页式结合这两部分的优点。段页式系统先将用户程序分成若干段，再将每个段分成若干个页。地址结构由段号、段内页号、页内地址构成。

![作业地址空间和地址结构](https://zuyuxia.github.io//img/%E4%BD%9C%E4%B8%9A%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png)

## 页面替换算法

### OPT 最佳置换算法

置换在将来最迟才会被访问的页面。因为无法预知哪一个页面最长时间以后被使用，所以该算法不能实现。意义在于可作为衡量其他算法优劣的标准。

### FIFO 先进先出

置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。

#### Belady异常

一般来说，缓存越大，命中率越高，缺页率越低。但是采用FIFO（先进先出）算法时，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。异常的原因是对于FIFO算法来说，在同一时刻，使用4个页框时缓存中保存的页面并不完全包含使用3个页框时保存的页面，二者不是超集子集关系，造成都某些特殊的页面请求序列，4个页框命中率反而低。而对LRU算法，任何时刻，缓存大的算法中保存的页面，都包含了缓存小的算法中的页面，多以缓存越大，命中率越高。

### LRU 最近最少使用

核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。

最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：

1. 新数据插入到链表头部；

2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
3. 当链表满的时候，将链表尾部的数据丢弃。

### LFU 最不经常使用

核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。

## 虚拟内存

- 增大内存空间，把主存看作磁盘地址空间的缓存

- 为每个进程提供了一致的地址空间，简化内存管理

  每个进程有一个独立的页表，有独立的虚拟地址空间

  比如每个进程代码段总是从0x400000开始

- 保护每个进程的地址空间不被其他进程破坏

  操作系统会控制进程对内存系统的访问

## 虚拟地址转换

先查TLB，TLB中找到了就可以直接获得物理地址

查页表，页表hit（entry的p位为1）则当前页在屋里内存中，获得地址后更新TLB，进行权限检测，如果权限有问题则Segmentation Fault

entry的p位为0则page fault，可能是malloc之后还没有分配空间，先分物理内存再entry的p位置1；或者页面内容在外部disk，则换入物理内存更新entry地址映射，p位置1

## 进程与线程之间的区别

[进程和线程之间有什么根本性的区别？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/44087187/answer/136188761)

进程是资源所有的单位，线程是执行与调度的单位。

进程的资源可以包括内存、文件、程序上下文、IO设备等。

线程各自拥有寄存器、栈、PC等

## 进程有哪些状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核CPU下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

## 进程调度策略

- 先来先服务
- 短作业优先
- 高优先权优先
- 高相应比优先
- 时间片轮转
- 多级反馈队列

## 切换线程时寄存器中的数据怎么办

数据入栈，每个线程有自己的栈空间

## 进程之间通信

- 管道：数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 命名管道：也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享内存：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。往往和其他通信机制配合，如信号量。
- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。
- 套接字：Socket
- 信号：SIGHUP、SIGINT之类

## 线程之间通信

- 共享内存：volatile
- 消息传递：wait/notify join

## 进程的内存空间

![img](https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

text：程序代码段

data：在程序运行初已经对变量进行初始化的数据

bss：在程序运行初未对变量进行初始化的数据（静态变量等）

heap：存储动态内存分配，需要程序员手工分配，手工释放

stack：存储局部、临时变量，函数调用时，存储函数的返回指针，用于控制函数的调用和返回。

## 函数调用堆栈变化

![img](https://img-blog.csdn.net/20180814161542620?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIyMTgzMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/20180814161542800?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIyMTgzMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/2018081416154326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIyMTgzMDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 用户态、内核态

系统调用将Linux分为用户态和内核态 //todo

## 你了解什么锁？我说了读写锁。怎么做的？我答了信号量。那信号量怎么实现的？不知道

TODO

## 死锁产生的必要条件

- 互斥条件

  资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。

- 不可剥夺条件

  进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。

- 请求和保持条件

  进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。

- 循环等待条件

  在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。

## 解决死锁的方法

### 死锁防止

破坏死锁的四个必要条件

#### 破坏互斥条件

使资源同时访问而非互斥使用。如只读数据文件可采用。这种做法在许多场合是不适用的。

#### 破坏不可剥夺条件

方法一：占有资源的进程若要申请新资源，必须主动释放已占有资源，若需要此资源，应该向系统重新申请。

方法二：资源分配管理程序为进程分配新资源时，若有则分配；否则将剥夺此进程已占有的全部资源，并让进程进入等待资源状态，资源充足后再唤醒它重新申请所有所需资源。

#### 破坏请求和保持条件

采用静态分配的方式，进程必须在执行之前就申请需要的全部资源，且直至所要的资源全部得到满足后才开始执行。实现简单，但是严重的减低了资源利用率。

#### 破坏循环等待条件

给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。

### 死锁避免

银行家算法、安全状态

### 死锁检测和恢复

略

## 硬连接与软连接

硬连接不会建立自己的inode索引和block（数据块），而是直接指向源文件的inode信息。硬连接不能跨文件系统，因为不同文件系统中inode号是重新计算的

软连接可以看做一个记录源文件指向的文件

# 体系结构

## 处理器流水线

取指、指令译码、计算操作数地址、取操作数、执行指令、写回

## 一个加法运算在CPU中的过程

10个进程每个运行一秒，cpu是怎么做的，10秒能跑完这10个进程吗

