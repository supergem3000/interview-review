# 计算机网络

## 七层网络模型

[OSI七层模型基础知识及各层常见应用 WANGZHEN-CSDN博客 osi七层模型](https://blog.csdn.net/qq_16093323/article/details/79582554)

| OSI                    | TCP/IP | 五层       |
| ---------------------- | ------ | ---------- |
| 应用层                 | 应用层 | 应用层     |
| 表示层                 |        |            |
| 会话层                 |        |            |
| 传输层（Segment）      | 传输层 | 传输层     |
| 网络层（Packet）       | 网络层 | 网络层     |
| 数据链路层（帧 Frame） | 链路层 | 数据链路层 |
| 物理层（比特 bit）     |        | 物理层     |

### 物理层

通过物理介质传输比特流。

常用设备：集线器、中继器、调制解调器、网线、双绞线、同轴电缆

### 数据链路层*（待完善）

将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。

MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。

常用设备：网卡、网桥、二层交换机

协议

### 网络层

本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。

常用设备：路由器、三层交换机

协议：IP、ICMP

### 传输层

TCP、UDP

### 会话层

### 表示层

### 应用层

HTTP、FTP、DNS、SMTP

## 网络分层的缘由

分层可以更好地明确每一层的职责

需要一个统一标准

（运维时网络工程师容易排查问题？防止甩锅）

## MAC地址

硬件地址，识别到数据链路上的设备。常用的以太网和无线局域网，都是使用 MAC 地址作为地址标识符进行通信的。（可以把IP地址看作逻辑地址，映射到MAC地址）

## TCP UDP

|              | UDP                                        | TCP                                    |
| :----------- | :----------------------------------------- | -------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

## 三次握手四次挥手

### 三次握手的原因

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

### 为什么需要TIME_WAIT

主动关闭连接方要确认被动方收到ACK。如果被动方没收到ACK还会重试向主动方发送FIN的。2MSL时间就是2个网络最大存活时间。2MSL没收到FIN就认为被动方收到了ACK

## TCP协议如何保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

## tcp拥塞处理

1. 慢开始。发送方拥塞窗口cwnd的值从1开始，指数增长。

2. 拥塞避免。cwnd值达到门限后开始拥塞避免算法，cwnd只能线性加1。

   发生超时重传等网络拥塞，cwnd置为1，慢开始门限变为原来的一半。

3. 快重传、快恢复。因为可能个别报文丢失，但实际上网络未发生拥塞。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731184314574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731184640178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190731184935595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)

## 滑动窗口

![img](https://images2017.cnblogs.com/blog/1232796/201710/1232796-20171016103123177-958324725.jpg)

用于网络数据传输时的流量控制，以避免拥塞的发生。

该协议允许发送方在停止并等待确认前发送多个数据分组，可以加速数据的传输，提高网络吞吐量。

## 拆包、粘包

![阿里Java一面：熟悉TCP粘包、拆包？说说粘包、拆包产生原因](https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzlmMzA2N2I5NWNmMTRlYWY5MjU4ZjJiY2VmODA5OGI5?x-oss-process=image/format,png)

客户端分别发送了两个数据包D1和D2给服务端，可能出现四种情况：

1. 服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包
2. 服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包
3. 服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包
4. 服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。

[TCP粘包、拆包以及粘包、拆包产生原因_johnhuster的专栏-CSDN博客_tcp拆包粘包](https://jonhuster.blog.csdn.net/article/details/102806307)

## UDP如何实现可靠传输

参照TCP实现可靠传输的方式，在应用层上实现。（比如精简掉TCP中的拥塞控制、慢启动等）

## 输入网址到获取页面的过程

略

## HTTP1.0、1.1、2.0、3*

### HTTP1.1对比HTTP1.0

HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，在HTTP1.1中默认开启长连接keep-alive

HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。

引入了更多缓存控制策略，新增了24个错误状态响应码

### HTTP2.0对比HTTP1.1

HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。

HTTP1.1中消息主题会gzip压缩，但header不会。HTTP2.0会对header进行压缩（因为header越来越复杂）

支持服务器推送

### HTTP3

在UDP协议上新增QUIC协议，代替TCP协议中关于可靠、流量控制的部分。过于先进，暂时忽略

## HTTPS SSL 加密原理

[彻底搞懂HTTPS的加密原理 - 顾伊凡 YGY的文章 - 知乎](https://zhuanlan.zhihu.com/p/43789231)

### 对称加密

有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密。

### 非对称加密

有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。

### 为什么不直接用非对称加密

非对称加密算法非常耗时，而对称加密快很多。

### 非对称加密+对称加密

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

### 中间人攻击

中间人在浏览器和服务器之间。浏览器认为中间人是服务器，服务器认为中间人是浏览器。

根本原因在于浏览器无法确认收到的公钥是不是网站自己的。

### 数字证书

网站在使用HTTPS前，需要向CA机构申领一份数字证书，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。

### 数字签名

用于防止数字证书被篡改。

![数字签名的生成与验证](https://pic2.zhimg.com/80/v2-7c78935389af46e197e96d9cd91c06dd_1440w.jpg)

数字签名的制作过程：

1. CA机构拥有非对称加密的私钥和公钥。
2. CA机构对证书明文数据T进行hash。
3. 对hash后的值用私钥加密，得到数字签名S。

浏览器验证过程：

1. 拿到证书，得到明文T，签名S。
2. 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。），得到S’。
3. 用证书里指明的hash算法对明文T进行hash得到T’。
4. 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。

### 为什么制作数字签名时需要hash一次

性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息，这样加解密就快很多。（其他深入原因见：[Why hash the message before signing it with RSA? - Cryptography Stack Exchange](https://crypto.stackexchange.com/questions/12768/why-hash-the-message-before-signing-it-with-rsa/12780#12780)）

### 怎么证明CA机构的公钥是可信的

操作系统、浏览器本身会预装一些它们信任的根证书。CA机构的公钥也可以用数字证书来证明。

### 每次进行HTTPS请求时都必须**在SSL/TLS层进行握手传输密钥吗**

服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。

## HTTP复用TCP和什么header有关？

`Keep-Alive`

用来告知服务器：我想要保存此次连接，我稍后还会请求，这样我们可以避免再次TCP三次握手。

## HTTP状态码

### 2XX 成功

- 200 OK：从客户端发来的请求在服务端被正常处理了。
- 204 No Content：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
- 206 Partial Content：该状态码表示服务端进行了范围请求，而服务器成功执行了这部分的GET请求。

### 3XX 重定向

- 301 Moved Permanently：永久重定向。表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。
- 302 Found：临时重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 和301状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。
- 304 Not Modified：表示客户端发送附带条件的请求时，服务器允许请求访问资源，但未满足条件的情况。304虽然被划分在3XX类别中，但是和重定向没有关系。（资源缓存用）

### 4XX 客户端错误

- 400 Bad Request：请求报文中存在语法错误。
- 401 Unauthorized：发送请求需要有通过HTTP认证的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。
- 403 Forbidden：对请求资源的访问被服务器拒绝了。（如访问权限问题）
- 404 Not Found：服务器上无法找到请求的资源。

#### 401与403的区别

都是拒绝访问，401相应应该用来表示缺失或错误的认证，403表示用户认证后，但权限不足，无法对该资源进行操作

### 5XX 服务器错误

- 500 Internal Server Error：服务器端在执行请求时发生了错误。
- 503 Service Unavailable：服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。

## HTTP缓存

### 强缓存

强缓存不会将请求发送到服务器，`Expires`和`Cache-Control`两个字段来控制

- `Expires`：用来指定资源到期的时间点，如`Expires:Thu,31 Dec 2037 23:59:59 GMT`

- `Cache-Control`：是一个相对时间，如`Cache-Control:3600`代表着资源的有效期是3600秒。

两个字段同时启用的优先级有争议？

### 协商缓存

会将请求发送到服务器，服务器判断是否命中协商缓存

- `Last-Modified/If-Modify-Since`：第一次请求时服务器返回的header会加上`Last-Modified`，浏览器再次请求时发送的header会包含`If-Modify-Since`来让服务器判断是否命中缓存
- `ETag/If-None-Match`：ETag是一个校验码，可以保证每一个资源是唯一的，ETag值的变更则说明资源状态已经被修改。

#### 既生Last-Modified何生Etag？

Last-Modified标注的最后修改只能精确到秒级

如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了

可能存在服务器没有准确获取文件修改时间的情形

## 同源政策

A网页设置的 Cookie，B网页不能打开，除非这两个网页"同源"。同源指协议相同、域名相同、端口相同。 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

### 非同源的行为限制

1. Cookie、LocalStorage和IndexDB无法读取。
2. DOM无法获得。
3. AJAX请求不能发送。

### Cookie

两个网站一级域名相同、二级域名不同，浏览器允许通过设置`document.domain`共享Cookie，LocalStorage和IndexDB不行。

服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名。如

```http
Set-Cookie: key=value; domain=.example.com; path=/
```

### iframe

如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和`window.open`方法打开的窗口，它们与父窗口无法通信。

如果两个窗口一级域名相同，只是二级域名不同，那么设置document.domain`属性，就可以规避同源政策，拿到DOM。

### AJAX

AJAX请求只能发给同源的网址，否则就报错。

有三种方法规避这个限制

1. JSONP
2. WebSocket
3. CORS

## CORS 跨域资源共享

### 简单请求与非简单请求

简单请求满足以下两大条件：

1. 请求方法是以下三种之一：
   - HEAD
   - GET
   - POST
2. HTTP的头信息不超出以下几种字段：
   - Accept
   - Accept-Language
   - Content-Language
   - Last-Event-ID
   - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。

凡是不同时满足上面两个条件，就属于非简单请求。

### 简单请求基本流程

在头信息之中增加一个Origin字段。

如果Origin指定的源不再许可范围内，服务器会返回一个正常的HTTP回应。这个回应的头不包含Access-Control-Allow-Origin字段，就表示出错了，被`XMLHttpRequest`的`onerror`回调函数捕获。注意HTTP回应的状态码可能是200，不能通过状态码识别错误。

如果Origin指定的域名在许可范围内，服务器返回的响应会多出几个头信息字段：

1. Access-Control-Allow-Origin

   必选。要么是请求时Origin的值，要么是`*`，表示接受任意域名的请求。

2. Access-Control-Allow-Credentials

   可选。布尔值，表示是否允许发送Cookie。

3. Access-Control-Expose-Headers

   可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。

### 非简单请求基本流程

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是`application/json`。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为预检请求。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

预检请求用的请求方法是OPTIONS。

预检请求的头信息包括两个特殊字段：

1. Access-Control-Request-Method

   必选。用来列出浏览器的CORS请求会用到哪些HTTP方法。

2. Access-Control-Request-Headers

   该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。

如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。

服务器回应的其他CORS相关字段如下：

1. Access-Control-Allow-Methods

   必选。它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

2. Access-Control-Allow-Headers

   如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

3. Access-Control-Allow-Credentials

   与简单请求时的含义相同。

4. Access-Control-Max-Age

   可选，用来指定本次预检请求的有效期，单位为秒。在此期间，不用发出另一条预检请求。

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样。

## XSS攻击

例如博客文章内容是一段script，别人看的时候就会自动执行这段script

如何防范？后端对提交数据过滤；前端做特殊字符替换

## CSRF攻击 跨站请求伪造

用户端C登陆了服务端S的网站，记录了Cookie。危险网站X使用户访问S并发送一个请求，C在不知道的情况下发送了请求，而S不知道是X发送的。X达到了模拟用户端C进行操作的目的。

> 最简单例子：
>
> 某网站登出URL为https://www.bilibili.com/logout，某恶意网站的HTML代码中有以下部分
>
> ```html
> <img src="https://www.bilibili.com/logout">
> ```
>
> 这样在用户不知情的情况下自己登出了该网站。

使用GET请求进行数据操作最容易遭到CSRF攻击。

该用POST请求也不能避免，因为恶意网站可以通过JavaScript来发送POST请求。

### 防御手段

获得网站的页面表单，添加一项包含随机数的隐藏的表单项。并把随机数载入cookie。用户发送请求时把隐藏项带上。后台解析请求是否合法。

## Ping命令使用的什么协议？

ICMP 网络层协议